options {
    STATIC = false;
    JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(Parser)

package org.example.javacc;
import org.example.ast.*;

public class Parser {
}

PARSER_END(Parser)

/* Ignore Whitespace */
SKIP : {" " |  "\n" | "\r" | "\r\n" | "\t" }

/* Ignore Comments */
SKIP: {
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

/* Punctuation */
TOKEN: {
  <LSQUIRLY: "{">
| <RSQUIRLY: "}">
| <LPAREN: "(" >
| <RPAREN: ")" >
| <LBRACKET: "[">
| <RBRACKET: "]" >
| <COMMA: ",">
| <SEMICOLON: ";">
| <DOT: ".">
}

/* Keywords */
TOKEN: {
  <CLASS: "class">
| <PUBLIC: "public">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <EXTENDS: "extends">
| <RETURN: "return">
| <STRING: "String">
| <IF: "if">
| <ELSE: "else">
| <WHILE: "while">
| <THIS: "this">
| <NEW: "new">
| <LENGTH: "length">
| <SOUT: "System.out.println">
}

/* Types */
TOKEN: {
  <INT: "int">
| <INT_ARRAY: "int[]">
| <BOOLEAN: "boolean">
}

/* Literals */
TOKEN: {
  <TRUE_LITERAL: "true">
| <FALSE_LITERAL: "false">
| <#DIGIT: ["0"-"9"]>
| <#LETTER: ["a"-"z", "A"-"Z"]>
| <IDENTIFIER: <LETTER>(<LETTER> | <DIGIT> | "_")* >
| <INTEGER_LITERAL:(<DIGIT>)+>
}

/* Operators */
TOKEN: {
  <EQ: "=">
| <AND: "&&">
| <LT: "<">
| <PLUS: "+">
| <MINUS: "-">
| <STAR: "*">
| <BANG: "!">
}

void Program(): {}
{
    MainClass()
    (ObjectDecl())*
    <EOF>
}

/* Entry Point */
void MainClass(): {}
{
    <CLASS>
    Identifier()
    <LSQUIRLY> <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING> <LBRACKET> <RBRACKET>
    Identifier()
    <RPAREN> <LSQUIRLY>
    Statement()
    <RSQUIRLY> <RSQUIRLY>
}

void ObjectDecl(): {}
{
    LOOKAHEAD(3) ClassDecl()
|   ClassExtendsDecl()
}

void ClassDecl(): {}
{
    <CLASS>
    Identifier()
    <LSQUIRLY>
    (VarDecl())*
    (MethodDecl())*
    <RSQUIRLY>
}

void ClassExtendsDecl(): {}
{
    <CLASS>
    Identifier()
    <EXTENDS>
    Identifier()
    <LSQUIRLY>
    (VarDecl())*
    (MethodDecl())*
    <RSQUIRLY>
}

Type Type(): {}
{
    <INT_ARRAY>
    {return new IntArrayType();}
|   <INT>
    {return new IntegerType();}
|   <BOOLEAN>
    {return new BooleanType();}
|   <IDENTIFIER>
    {return new IdentifierType(token.image);}
}

Formal Formal(): {
    Formal.FormalBuilder builder = Formal.builder();
    Type type;
}
{
    type = Type()
    {builder.type(type);}
    <IDENTIFIER>
    {builder.name(token.image);}
    {return builder.build();}
}

Formal FormalRest(): {}
{
    <COMMA>
    {return Formal();}
}

FormalList FormalList(): {
    Formal form;
    FormalList list = new FormalList();
}
{
    form = Formal()
    {list.addFormal(form);}
    (
        form = FormalRest()
        {list.addFormal(form);}
    )*
    {return list;}
}

VarDecl VarDecl(): {
    VarDecl.VarDeclBuilder builder = VarDecl.builder();
    Type type;
}
{
    type = Type()
    {builder.type(type);}
    <IDENTIFIER>
    {builder.name(token.image);}
    <SEMICOLON>
    {return builder.build();}
}

void MethodDecl(): {
    FormalList formals;
}
{
    <PUBLIC>
    Type()
    Identifier()
    <LPAREN>
    (formals = FormalList())?
    <RPAREN>
    <LSQUIRLY>
    (LOOKAHEAD(2) VarDecl())*
    (Statement())*
    <RETURN>
    Expression()
    <SEMICOLON> <RSQUIRLY>
}

Identifier Identifier(): {}
{
    <IDENTIFIER>
    {return new Identifier(token.image);}
}

Expression Expression(): {
    Expression expr;
}
{
    LOOKAHEAD(Clause() <AND>) expr = AndExpression()
    {return expr;}
  | LOOKAHEAD(PrimaryExpression() <LT>) expr = LTExpression()
    {return expr;}
  | LOOKAHEAD(PrimaryExpression() <PLUS>) expr = PlusExpression()
    {return expr;}
  | LOOKAHEAD(PrimaryExpression() <MINUS>) expr = MinusExpression()
    {return expr;}
  | LOOKAHEAD(PrimaryExpression() <STAR>) expr = StarExpression()
    {return expr;}
  | LOOKAHEAD(PrimaryExpression() <LBRACKET>) expr = Lookup()
    {return expr;}
  | LOOKAHEAD(PrimaryExpression() <DOT> <LENGTH>) expr = LengthMethod()
    {return expr;}
  | LOOKAHEAD(PrimaryExpression() <DOT> Identifier() <LPAREN>) expr = CallExpression()
    {return expr;}
  | expr = Clause()
    {return expr;}
}

Expression ExpressionRest(): {}
{
    <COMMA>
    {return Expression();}
}

ExpressionList ExpressionList(): {
    Expression expr;
    ExpressionList list = new ExpressionList();
}
{
    expr = Expression()
    {list.addExpression(expr);}
    (
        expr = ExpressionRest()
        {list.addExpression(expr);}
    )*
    {return list;}
}

And AndExpression() :
{
    And.AndBuilder builder = And.builder();
    Expression lhe;
    Expression rhe;
}
{
    lhe = Clause()
  {builder.lhe(lhe);}
  <AND>
    rhe = Clause()
  {builder.rhe(rhe);}
  {return builder.build();}
}

LessThan LTExpression() :
{
    LessThan.LessThanBuilder builder = LessThan.builder();
}
{
  {builder.lhe(PrimaryExpression());}
  <LT>
  {builder.rhe(PrimaryExpression());}
  {return builder.build();}
}

Plus PlusExpression() :
{
    Plus.PlusBuilder builder = Plus.builder();
}
{
  {builder.lhe(PrimaryExpression());}
  <PLUS>
  {builder.rhe(PrimaryExpression());}
  {return builder.build();}
}

Minus MinusExpression() :
{
    Minus.MinusBuilder builder = Minus.builder();
}
{
  {builder.lhe(PrimaryExpression());}
  <MINUS>
  {builder.rhe(PrimaryExpression());}
  {return builder.build();}
}

Times StarExpression() :
{
    Times.TimesBuilder builder = Times.builder();
}
{
  {builder.lhe(PrimaryExpression());}
  <STAR>
  {builder.rhe(PrimaryExpression());}
  {return builder.build();}
}

ArrayLookup Lookup() :
{
    ArrayLookup.ArrayLookupBuilder builder = ArrayLookup.builder();
}
{
  {builder.array(PrimaryExpression());}
  <LBRACKET>
  {builder.idx(Expression());}
  <RBRACKET>
  {return builder.build();}
}

ArrayLength LengthMethod() :
{
    ArrayLength.ArrayLengthBuilder builder = ArrayLength.builder();
    Expression expr;
}
{
    expr = PrimaryExpression()
  {builder.array(expr);}
  <DOT> <LENGTH>
  {return builder.build();}
}

Call CallExpression() :
{
    Call.CallBuilder builder = Call.builder();
    ExpressionList list;
    Expression owner;
    Identifier method;
}
{
    owner = PrimaryExpression()
  {builder.owner(owner);}
  <DOT>
  method = Identifier()
  {builder.method(method);}
  <LPAREN>
  (
     list = ExpressionList()
     {builder.expressionList(list);}
  )?
  <RPAREN>
  {return builder.build();}
}

Expression Clause(): {
    Expression expr;
}
{
    expr = NotExpression()
    {return expr;}
  | expr = PrimaryExpression()
    {return expr;}
}

Expression PrimaryExpression(): {
    Expression expr;
}
{
    expr = IntegerLiteral()
    {return expr;}
|   expr = TrueLiteral()
    {return expr;}
|   expr = FalseLiteral()
    {return expr;}
|   expr = ThisLiteral()
    {return expr;}
|   expr = Identifier()
    {return expr;}
|   LOOKAHEAD(3) expr = NewArray()
    {return expr;}
|   expr = NewObject()
    {return expr;}
|   expr = ParenthesizedExpression()
    {return expr;}
}

IntegerLiteral IntegerLiteral(): {}
{
    <INTEGER_LITERAL>
    {return new IntegerLiteral(Integer.parseInt(token.image));}
}

True TrueLiteral(): {}
{
    <TRUE_LITERAL>
    {return new True();}
}

False FalseLiteral(): {}
{
    <FALSE_LITERAL>
    {return new False();}
}

This ThisLiteral(): {}
{
    <THIS>
    {return new This();}
}

NewObject NewObject(): {
    NewObject.NewObjectBuilder builder = NewObject.builder();
    Identifier id;
}
{
    <NEW>
    id = Identifier()
    {builder.identifier(id);}
    <LPAREN> <RPAREN>
    {return builder.build();}
}

Expression NewArray(): {
   NewArray.NewArrayBuilder builder = NewArray.builder();
   Expression size;
}
{
    <NEW> <INT> <LBRACKET>
    size = Expression()
    {builder.size(size);}
    <RBRACKET>
    {return builder.build();}
}

Expression NotExpression(): {
    Expression expr;
}
{
    <BANG>
    expr = Expression()
    {return new Not(expr);}
}

Expression ParenthesizedExpression(): {
    Expression expr;
}
{
    <LPAREN>
    expr = Expression()
    <RPAREN>
    {return expr;}
}

void BlockStatement(): {}
{
    <LSQUIRLY> (Statement())* <RSQUIRLY>
}

void IfStatement(): {}
{
    <IF> <LPAREN>
    Expression()
    <RPAREN>
    Statement()
    <ELSE>
    Statement()
}

void WhileStatement(): {}
{
    <WHILE> <LPAREN>
    Expression()
    <RPAREN>
    Statement()
}

void SoutStatement(): {}
{
    <SOUT> <LPAREN>
    Expression()
    <RPAREN> <SEMICOLON>
}

void AssignStatement(): {}
{
    Identifier()
    <EQ>
    Expression()
    <SEMICOLON>
}

void ArrayAssignStatement(): {}
{
    Identifier()
    <LBRACKET>
    Expression()
    <RBRACKET> <EQ>
    Expression()
    <SEMICOLON>
}

void Statement(): {}
{
    BlockStatement()
|   IfStatement()
|   WhileStatement()
|   SoutStatement()
|   LOOKAHEAD(2) AssignStatement()
|   LOOKAHEAD(2) ArrayAssignStatement()
}